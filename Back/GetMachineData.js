const config = require('./config.json')
const csv = require('csv-parser')
const fs = require('fs')

const MachineStates = {
  OFF: 0,
  UNLOADED: 1,
  IDLE: 2,
  LOADED: 3
}

function getMachineState (value) {
  let state = null
  if (value >= config.filters.minValue && value <= config.filters.maxValue) {
    state = MachineStates.LOADED
    if (value <= config.filters.idleLimit) {
      state = MachineStates.IDLE
      if (value <= config.filters.unloadedLimit) {
        state = MachineStates.UNLOADED
      }
    }
  }
  return state
}

/**
  * @desc Process each CSV row and find states cahnges over the data.
  * @param  string $machineName - the machines name to search
  * @param  string $machine - the machines structure to store data
  * @param  string $row - CSV row generated by csv-parser
  * @returns null
*/
function processMachine (machineName, machine, row) {
  if (row[config.fileds.machine] == machineName && row[config.fileds.metric] == config.metric) {
    const time = Number(row[config.fileds.time])
    const value = Number(row[config.fileds.value])
    // Get the current state based on the value
    const state = getMachineState(value)

    if (state !== null) {
      const changesLength = machine.changes.length
      // If is the first value, should set the first state
      if (changesLength === 0) {

        // If the first value is far from the initial time, the first values will be OFF
        if (time - config.filters.timeFrom > 0) {
          machine.changes.push({time: config.filters.timeFrom, state: MachineStates.OFF})
        }

        // Set the state based on the value
        machine.changes.push({time, state})
      } else {

        // If is not the first value, search for a state change
        const lastChange = machine.changes[changesLength - 1]
        if (time - machine.lastInput > config.timeOffline) {
          // If the last input was far, should create a OFF value
          machine.changes.push({time: machine.lastInput + config.deltaTime, state: MachineStates.OFF})

          // Set the state based on the value
          machine.changes.push({time, state})
        } else if (lastChange.state !== state) {
          // Set the state based on the value
          machine.changes.push({time, state})
        }
      }
    }

    machine.lastInput = time
  }
}

function analyzeChanges (machine) {
  // Add last state change
  if (config.filters.timeTo - machine.lastInput > config.timeOffline) {
    machine.changes.push({time: machine.lastInput + config.deltaTime, state: MachineStates.OFF})
  }

  // Calculate each state time
  machine.stateTimes = [0, 0, 0, 0]
  let previouseChange = null
  machine.changes.forEach(change => {
    if (previouseChange !== null) {
      machine.stateTimes[previouseChange.state] += (change.time - previouseChange.time)
    }
    previouseChange = change
  })
  machine.stateTimes[previouseChange.state] += (config.filters.timeTo - previouseChange.time)
}

const getMachineData = function (req, res) {
  if (!req.query.name || req.query.name.length == 0) {
    res.statusMessage = 'Machine name can not be empty.'
    res.status(500).end()
    return
  }

  const machine = {
    name: req.query.name,
    source: config.dataFile,
    metric: config.metric,
    filters: config.filters,
    lastInput: null,
    changes: []
  }

  // Open the file
  fs.createReadStream(config.dataFile)
    .pipe(csv(config.dataHeaders))
    .on('data', (row) => {
      // Process each row
      processMachine(req.query.name, machine, row)
    })
    .on('end', () => {
      // Send the response after process all the file.
      analyzeChanges(machine)
      res.send(machine)
    })
}

module.exports = getMachineData
